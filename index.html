<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Scene Viewer with Physics & Keyboard</title>
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    .controls, .lights, .vertical, .reset { position: absolute; z-index: 1000; }
    .controls {
      bottom: 20px; left: 90px;
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      gap: 5px;
    }
    .vertical {
      bottom: 70px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .reset { bottom: 20px; left: 20px; }
    .lights {
      top: 20px; right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    button {
      background-color: #333;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 18px;
      cursor: pointer;
      opacity: 0.85;
      user-select: none;
    }
    button:hover { opacity: 1; }
  </style>
</head>
<body>

<!-- Controls -->
<div class="controls">
  <button title="Move Forward Left" onclick="move('forward-left')">↖</button>
  <button title="Move Forward" onclick="move('forward')">↑</button>
  <button title="Move Forward Right" onclick="move('forward-right')">↗</button>
  <button title="Move Left" onclick="move('left')">←</button>
  <button title="Jump" onclick="jump()">⤒</button>
  <button title="Move Right" onclick="move('right')">→</button>
  <button title="Move Backward Left" onclick="move('backward-left')">↙</button>
  <button title="Move Backward" onclick="move('backward')">↓</button>
  <button title="Move Backward Right" onclick="move('backward-right')">↘</button>
</div>

<!-- Vertical Camera Movement -->
<div class="vertical">
  <button title="Move Camera Up" onclick="moveVertical(0.3)">↑</button>
  <button title="Move Camera Down" onclick="moveVertical(-0.3)">↓</button>
</div>

<!-- Reset Button -->
<div class="reset">
  <button title="Reset Camera Position" onclick="resetCamera()">⟳</button>
</div>

<!-- Light Controls -->
<div class="lights">
  <button title="Toggle Ambient Light" onclick="toggleLight('ambient')">Toggle Ambient</button>
  <button title="Toggle Directional Light" onclick="toggleLight('directional')">Toggle Directional</button>
  <button title="Toggle Point Light" onclick="toggleLight('point')">Toggle Point</button>
</div>

<!-- A-Frame Scene -->
<a-scene physics="gravity: -9.8; debug: false" embedded>
  <a-assets>
    <a-asset-item id="my-obj" src="https://albertmensah.github.io/test/test.obj"></a-asset-item>
    <a-asset-item id="my-mtl" src="https://albertmensah.github.io/test/test.mtl"></a-asset-item>
    <a-asset-item id="gas-station" src="https://albertmensah.github.io/test/Old%20Gas%20Station%20Interior%20(Splat).glb"></a-asset-item>
  </a-assets>

  <a-sky color="#87CEEB"></a-sky>

  <!-- Lights -->
  <a-light id="ambientLight" type="ambient" color="#ffffff" intensity="1" visible="true"></a-light>
  <a-light id="directionalLight" type="directional" color="#ffffff" intensity="3" position="2 4 3" visible="true"></a-light>
  <a-light id="pointLight" type="point" color="#ffffff" intensity="3" distance="10" position="0 3 3" visible="true"></a-light>

  <!-- Camera rig with physics dynamic body -->
  <a-entity id="rig" position="0 1.6 3" dynamic-body="shape: capsule; mass: 5; linearDamping: 0.9; angularDamping: 1">
    <a-camera id="camera" look-controls wasd-controls-enabled="false"></a-camera>
  </a-entity>

  <!-- OBJ Model -->
  <a-entity obj-model="obj: #my-obj; mtl: #my-mtl"
            position="0 0 -3"
            scale="1 1 1"
            static-body></a-entity>

  <!-- GLB Model -->
  <a-entity gltf-model="#gas-station"
            position="5 0 -5"
            scale="1 1 1"
            static-body></a-entity>

  <!-- Ground -->
  <a-plane rotation="-90 0 0"
           width="50"
           height="50"
           color="#8B4513"
           static-body></a-plane>
</a-scene>

<script>
  const rig = document.querySelector('#rig');
  const camera = document.querySelector('#camera');

  // Movement parameters
  const stepVelocity = 3; // units per second
  const verticalStep = 0.3; // vertical camera step on button press

  // Track which keys are pressed for smooth movement
  const keysPressed = {};

  // Direction vectors for movement keys
  const directionVectors = {
    forward: { x: 0, z: -1 },
    backward: { x: 0, z: 1 },
    left: { x: -1, z: 0 },
    right: { x: 1, z: 0 },
  };

  // Combine directions for diagonals
  function getMovementVector() {
    let x = 0, z = 0;
    if (keysPressed['w'] || keysPressed['ArrowUp']) {
      z -= 1;
    }
    if (keysPressed['s'] || keysPressed['ArrowDown']) {
      z += 1;
    }
    if (keysPressed['a'] || keysPressed['ArrowLeft']) {
      x -= 1;
    }
    if (keysPressed['d'] || keysPressed['ArrowRight']) {
      x += 1;
    }

    // Normalize vector to prevent faster diagonal speed
    const length = Math.hypot(x, z);
    if (length > 0) {
      x /= length;
      z /= length;
    }
    return { x, z };
  }

  // Update rig velocity based on keyboard input
  function updateVelocity() {
    if (!rig.body) return;

    const moveVec = getMovementVector();
    // Convert movement direction relative to camera orientation
    const cameraRotation = camera.object3D.getWorldDirection(new THREE.Vector3());
    // We'll ignore y component for horizontal movement
    cameraRotation.y = 0;
    cameraRotation.normalize();

    // Calculate right vector from camera direction
    const rightVec = new THREE.Vector3();
    rightVec.crossVectors(cameraRotation, new THREE.Vector3(0, 1, 0)).normalize();

    // Compute velocity vector relative to camera rotation
    const velocity = new THREE.Vector3();
    velocity.addScaledVector(cameraRotation, moveVec.z * stepVelocity);
    velocity.addScaledVector(rightVec, moveVec.x * stepVelocity);

    // Apply velocity to physics body (keep current y velocity for gravity and jumps)
    rig.body.velocity.x = velocity.x;
    rig.body.velocity.z = velocity.z;
  }

  // Move camera rig with buttons (instant velocity burst)
  function move(direction) {
    if (!rig.body) return;

    const step = stepVelocity;
    const pos = rig.object3D.position;
    let dx = 0, dz = 0;

    switch(direction) {
      case 'forward': dz = -step; break;
      case 'backward': dz = step; break;
      case 'left': dx = -step; break;
      case 'right': dx = step; break;
      case 'forward-left': dx = -step; dz = -step; break;
      case 'forward-right': dx = step; dz = -step; break;
      case 'backward-left': dx = -step; dz = step; break;
      case 'backward-right': dx = step; dz = step; break;
    }

    // Calculate movement relative to camera direction
    const cameraRotation = camera.object3D.getWorldDirection(new THREE.Vector3());
    cameraRotation.y = 0;
    cameraRotation.normalize();

    const rightVec = new THREE.Vector3();
    rightVec.crossVectors(cameraRotation, new THREE.Vector3(0, 1, 0)).normalize();

    // Movement vector in world space
    const moveVec = new THREE.Vector3();
    moveVec.addScaledVector(cameraRotation, dz);
    moveVec.addScaledVector(rightVec, dx);

    // Add instantaneous velocity burst
    rig.body.velocity.x += moveVec.x;
    rig.body.velocity.z += moveVec.z;
  }

  // Move camera rig vertically by changing rig position (since physics capsule is vertical)
  function moveVertical(amount) {
    const pos = rig.getAttribute('position');
    rig.setAttribute('position', { x: pos.x, y: pos.y + amount, z: pos.z });
  }

  // Jump function with ground check (only jump if vertical velocity near zero)
  function jump() {
    if (!rig.body) return;
    if (Math.abs(rig.body.velocity.y) < 0.05) {
      rig.body.velocity.y = 5;
    }
  }

  // Reset camera to start position and zero velocity
  function resetCamera() {
    rig.setAttribute('position', { x: 0, y: 1.6, z: 3 });
    if (rig.body) {
      rig.body.velocity.set(0, 0, 0);
      rig.body.angularVelocity.set(0, 0, 0);
    }
  }

  // Toggle visibility of lights by ID
  function toggleLight(type) {
    const idMap = {
      ambient: 'ambientLight',
      directional: 'directionalLight',
      point: 'pointLight'
    };
    const light = document.getElementById(idMap[type]);
    if (!light) return;
    const visible = light.getAttribute('visible');
    light.setAttribute('visible', !visible);
  }

  // Keyboard event handlers
  window.addEventListener('keydown', (e) => {
    // Prevent default scrolling behavior on arrow keys
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
      e.preventDefault();
    }
    if (!keysPressed[e.key.toLowerCase()]) {
      keysPressed[e.key.toLowerCase()] = true;
      updateVelocity();
    }
    // Space for jump
    if (e.key === ' ') jump();
  });

  window.addEventListener('keyup', (e) => {
    if (keysPressed[e.key.toLowerCase()]) {
      keysPressed[e.key.toLowerCase()] = false;
      updateVelocity();
    }
  });

  // Update velocity continuously while keys are pressed
  // This prevents the rig from sliding when keys are released
  setInterval(() => {
    updateVelocity();
  }, 50);

</script>

</body>
</html>
